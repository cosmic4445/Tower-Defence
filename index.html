<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower Defense</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #36393F;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    body.light-mode {
      background: #f0f4f8;
    }
    .screen {
      display: none;
      width: 100vw;
      height: 100vh;
      padding: 40px;
      overflow-y: auto;
    }
    .screen.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .menu-container {
      background: #2F3136;
      border-radius: 15px;
      padding: 40px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }
    .light-mode .menu-container {
      background: white;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    h1 {
      color: #7289DA;
      text-align: center;
      margin-bottom: 30px;
      font-size: 36px;
    }
    h2 {
      color: #7289DA;
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
    }
    .menu-btn {
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      background: #7289DA;
      color: white;
      transition: all 0.3s;
    }
    .menu-btn:hover {
      background: #5B6EAE;
      transform: translateY(-2px);
    }
    .menu-btn.secondary {
      background: #4E5D94;
    }
    .menu-btn.secondary:hover {
      background: #3E4A75;
    }
    .back-btn {
      background: #43B581;
      margin-bottom: 20px;
    }
    .back-btn:hover {
      background: #369968;
    }
    #gameScreen, #levelEditorScreen {
      padding: 0;
      position: relative;
    }
    #gameCanvas, #editorCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #gameHUD {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
    }
    .hud-panel {
      background: rgba(47, 49, 54, 0.95);
      padding: 15px 25px;
      border-radius: 10px;
      color: white;
      font-weight: bold;
      pointer-events: auto;
    }
    .light-mode .hud-panel {
      background: rgba(255, 255, 255, 0.95);
      color: #2F3136;
    }
    .stat {
      margin: 5px 0;
    }
    #towerMenu {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    .tower-btn {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #7289DA;
      color: white;
      transition: all 0.3s;
    }
    .tower-btn:hover:not(:disabled) {
      background: #5B6EAE;
      transform: translateY(-2px);
    }
    .tower-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .tower-btn.selected {
      background: #43B581;
    }
    #towerUI {
      position: absolute;
      background: rgba(47, 49, 54, 0.95);
      padding: 20px;
      border-radius: 10px;
      display: none;
      color: white;
      min-width: 200px;
    }
    .light-mode #towerUI {
      background: rgba(255, 255, 255, 0.95);
      color: #2F3136;
    }
    #towerUI button {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #7289DA;
      color: white;
      font-weight: bold;
    }
    #towerUI button:hover {
      background: #5B6EAE;
    }
    .input-group {
      margin: 15px 0;
    }
    .input-group label {
      display: block;
      color: #B9BBBE;
      margin-bottom: 5px;
      font-size: 14px;
    }
    .light-mode .input-group label {
      color: #4F5660;
    }
    .input-group input, .input-group select, .input-group textarea {
      width: 100%;
      padding: 10px;
      border: 2px solid #40444B;
      border-radius: 5px;
      background: #40444B;
      color: white;
      font-size: 14px;
    }
    .light-mode .input-group input,
    .light-mode .input-group select,
    .light-mode .input-group textarea {
      background: #f0f4f8;
      border-color: #cbd5e1;
      color: #2F3136;
    }
    .level-list {
      max-height: 400px;
      overflow-y: auto;
      margin: 15px 0;
    }
    .level-item {
      background: #40444B;
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .light-mode .level-item {
      background: #f0f4f8;
    }
    .level-item:hover {
      background: #4E5D94;
    }
    .light-mode .level-item:hover {
      background: #e2e8f0;
    }
    .level-item h3 {
      color: #7289DA;
      margin-bottom: 5px;
    }
    .level-item p {
      color: #B9BBBE;
      font-size: 14px;
      margin: 2px 0;
    }
    .light-mode .level-item p {
      color: #4F5660;
    }
    #editorToolbar {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(47, 49, 54, 0.95);
      padding: 15px;
      border-radius: 10px;
      color: white;
    }
    .light-mode #editorToolbar {
      background: rgba(255, 255, 255, 0.95);
      color: #2F3136;
    }
    .tool-btn {
      display: block;
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #7289DA;
      color: white;
      font-weight: bold;
    }
    .tool-btn:hover {
      background: #5B6EAE;
    }
    .tool-btn.active {
      background: #43B581;
    }
    #adminPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2F3136;
      padding: 30px;
      border-radius: 15px;
      display: none;
      z-index: 1000;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .light-mode #adminPanel {
      background: white;
    }
    #usernameModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-content {
      background: #2F3136;
      padding: 40px;
      border-radius: 15px;
      text-align: center;
      color: white;
    }
    .light-mode .modal-content {
      background: white;
      color: #2F3136;
    }
    #completionScreen {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2F3136;
      padding: 40px;
      border-radius: 15px;
      display: none;
      z-index: 1000;
      text-align: center;
      color: white;
    }
    .light-mode #completionScreen {
      background: white;
      color: #2F3136;
    }
    .shop-tab {
      display: none;
    }
    .shop-tab.active {
      display: block;
    }
    .shop-item {
      background: #40444B;
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .light-mode .shop-item {
      background: #f0f4f8;
    }
    .tab-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .tab-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #40444B;
      color: white;
      font-weight: bold;
    }
    .light-mode .tab-btn {
      background: #f0f4f8;
      color: #2F3136;
    }
    .tab-btn.active {
      background: #7289DA;
    }
  </style>
</head>
<body>
  <!-- Username Modal -->
  <div id="usernameModal">
    <div class="modal-content">
      <h1>Welcome!</h1>
      <div class="input-group">
        <label>Choose your username</label>
        <input type="text" id="usernameInput" maxlength="20" placeholder="Enter username...">
      </div>
      <p id="usernameMessage" style="margin: 10px 0; color: #43B581;"></p>
      <button class="menu-btn" onclick="setUsername()">Continue</button>
    </div>
  </div>

  <!-- Main Menu -->
  <div id="mainMenu" class="screen">
    <div class="menu-container">
      <h1>üè∞ Tower Defense</h1>
      <button class="menu-btn" onclick="showScreen('modeSelect')">Play</button>
      <button class="menu-btn secondary" onclick="showScreen('levelsMenu')">Levels</button>
      <button class="menu-btn secondary" onclick="showScreen('shopMenu')">Shop</button>
      <button class="menu-btn secondary" onclick="showScreen('levelEditor')">Level Editor</button>
      <button class="menu-btn secondary" onclick="showScreen('updateLog')">Update Log</button>
      <button class="menu-btn secondary" onclick="showScreen('settingsMenu')">Settings</button>
    </div>
  </div>

  <!-- Mode Selection -->
  <div id="modeSelect" class="screen">
    <div class="menu-container">
      <h1>Select Difficulty</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <button class="menu-btn" onclick="startGame('easy')">Easy (20 waves)</button>
      <button class="menu-btn" onclick="startGame('normal')">Normal (40 waves)</button>
      <button class="menu-btn" onclick="startGame('hard')">Hard (60 waves)</button>
      <button class="menu-btn" onclick="startGame('expert')">Expert (100 waves)</button>
    </div>
  </div>

  <!-- Levels Menu -->
  <div id="levelsMenu" class="screen">
    <div class="menu-container">
      <h1>Levels</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <button class="menu-btn" onclick="showScreen('officialLevels')">Official Levels</button>
      <button class="menu-btn" onclick="showScreen('browseLevels')">Browse Levels</button>
    </div>
  </div>

  <!-- Official Levels -->
  <div id="officialLevels" class="screen">
    <div class="menu-container">
      <h1>Official Levels</h1>
      <button class="menu-btn back-btn" onclick="showScreen('levelsMenu')">‚Üê Back</button>
      <div class="level-list" id="officialLevelList"></div>
    </div>
  </div>

  <!-- Browse Levels -->
  <div id="browseLevels" class="screen">
    <div class="menu-container">
      <h1>Community Levels</h1>
      <button class="menu-btn back-btn" onclick="showScreen('levelsMenu')">‚Üê Back</button>
      <div class="level-list" id="communityLevelList"></div>
    </div>
  </div>

  <!-- Shop Menu -->
  <div id="shopMenu" class="screen">
    <div class="menu-container">
      <h1>Shop</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <p style="color: #B9BBBE; text-align: center; margin-bottom: 20px;">Coins: <span id="shopCoins">0</span></p>
      <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchShopTab('gunner')">Gunner</button>
        <button class="tab-btn" onclick="switchShopTab('sniper')">Sniper</button>
        <button class="tab-btn" onclick="switchShopTab('wizard')">Wizard</button>
        <button class="tab-btn" onclick="switchShopTab('rifle')">Rifle</button>
        <button class="tab-btn" onclick="switchShopTab('powerups')">Powerups</button>
      </div>
      <div id="shopContent"></div>
    </div>
  </div>

  <!-- Update Log -->
  <div id="updateLog" class="screen">
    <div class="menu-container">
      <h1>Update Log</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <div class="input-group">
        <textarea id="updateLogText" rows="15" readonly>

v2.0.1 - Bug fix
 ‚Ä¢ Fixed thick roads in the editor

v2.0.0 - Major Update!
‚Ä¢ Added Level Editor
‚Ä¢ Added Shop system with tower skins
‚Ä¢ Added powerups (Damage Boost, Freeze, Price Reduction)
‚Ä¢ Added grid snap system for tower placement
‚Ä¢ Added tower upgrade and targeting system
‚Ä¢ Added community level browser
‚Ä¢ Added official levels section
‚Ä¢ Buffed Rifle tower (now 1000g)
‚Ä¢ Buffed Sniper range
‚Ä¢ Fixed tower placement overlap bug
‚Ä¢ Added wave completion rewards
‚Ä¢ Added username system

v1.0.0 - Initial Release
‚Ä¢ 4 Tower types
‚Ä¢ 5 Enemy types including Boss
‚Ä¢ Multiple difficulty modes
‚Ä¢ Wave-based gameplay
        </textarea>
      </div>
    </div>
  </div>

  <!-- Settings -->
  <div id="settingsMenu" class="screen">
    <div class="menu-container">
      <h1>Settings</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <button class="menu-btn" onclick="setTheme('dark')">Dark Mode</button>
      <button class="menu-btn" onclick="setTheme('light')">Light Mode</button>
      <button class="menu-btn secondary" onclick="location.reload()">Reload Game</button>
    </div>
  </div>

  <!-- Level Editor -->
  <div id="levelEditor" class="screen">
    <div class="menu-container">
      <h1>Level Editor</h1>
      <button class="menu-btn back-btn" onclick="showScreen('mainMenu')">‚Üê Back</button>
      <button class="menu-btn" onclick="createNewLevel()">New Level</button>
      <button class="menu-btn" onclick="loadSavedLevels()">Load Saved Level</button>
    </div>
  </div>

  <!-- Level Editor Screen -->
  <div id="levelEditorScreen" class="screen">
    <canvas id="editorCanvas"></canvas>
    <div id="editorToolbar">
      <h3 style="margin-bottom: 10px;">Tools</h3>
      <button class="tool-btn active" data-tool="road">Road</button>
      <button class="tool-btn" data-tool="rock">Rock</button>
      <button class="tool-btn" data-tool="erase">Erase</button>
      <hr style="margin: 10px 0;">
      <button class="tool-btn" onclick="testLevel()">Test Level</button>
      <button class="tool-btn" onclick="saveLevel()">Save Level</button>
      <button class="tool-btn" onclick="publishLevel()">Publish Level</button>
      <button class="tool-btn" onclick="exitEditor()">Exit</button>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="gameScreen" class="screen">
    <canvas id="gameCanvas"></canvas>
    <div id="gameHUD">
      <div class="hud-panel">
        <div class="stat">üí∞ Gold: <span id="gold">200</span></div>
        <div class="stat">‚ù§Ô∏è Lives: <span id="lives">20</span></div>
        <div class="stat">üåä Wave: <span id="wave">1</span></div>
      </div>
      <div class="hud-panel">
        <button class="menu-btn" id="startWaveBtn" onclick="startWave()">Start Wave</button>
      </div>
    </div>
    <div id="towerMenu">
      <button class="tower-btn" data-tower="gunner">Gunner (50g)</button>
      <button class="tower-btn" data-tower="sniper">Sniper (100g)</button>
      <button class="tower-btn" data-tower="wizard">Wizard (120g)</button>
      <button class="tower-btn" data-tower="rifle">Rifle (1000g)</button>
    </div>
    <div id="towerUI">
      <h3 id="towerUITitle">Tower Options</h3>
      <button onclick="upgradeTower()">Upgrade (Cost: <span id="upgradeCost">100</span>g)</button>
      <select id="towerTarget" onchange="changeTowerTarget()">
        <option value="first">Target: First</option>
        <option value="zombie">Target: Zombie</option>
        <option value="speed">Target: Speed Zombie</option>
        <option value="tank">Target: Tank</option>
        <option value="king">Target: King</option>
      </select>
      <button onclick="closeTowerUI()">Close</button>
    </div>
    <button class="tower-btn" id="leaveBtn" onclick="leaveGame()">Leave Game</button>
  </div>

  <!-- Completion Screen -->
  <div id="completionScreen">
    <h1>üéâ Level Complete!</h1>
    <p id="completionMessage"></p>
    <button class="menu-btn" onclick="nextLevel()">Next Level</button>
    <button class="menu-btn secondary" onclick="restartLevel()">Restart</button>
    <button class="menu-btn secondary" onclick="leaveGame()">Main Menu</button>
  </div>

  <!-- Admin Panel -->
  <div id="adminPanel">
    <h1>Admin Panel</h1>
    <button class="menu-btn" onclick="showAdminSection('publishLevel')">Publish Level</button>
    <button class="menu-btn" onclick="showAdminSection('unpublishLevel')">Unpublish Level</button>
    <h3 style="color: #7289DA; margin-top: 20px;">Give Coins</h3>
    <button class="menu-btn" onclick="giveCoins(10)">+10 Coins</button>
    <button class="menu-btn" onclick="giveCoins(100)">+100 Coins</button>
    <button class="menu-btn" onclick="giveCoins(1000)">+1000 Coins</button>
    <h3 style="color: #7289DA; margin-top: 20px;">Remove Coins</h3>
    <button class="menu-btn secondary" onclick="giveCoins(-10)">-10 Coins</button>
    <button class="menu-btn secondary" onclick="giveCoins(-100)">-100 Coins</button>
    <button class="menu-btn secondary" onclick="giveCoins(-1000)">-1000 Coins</button>
    <button class="menu-btn" style="margin-top: 20px;" onclick="closeAdmin()">Close</button>
  </div>

  <script>
    // Game State
    let currentScreen = 'usernameModal';
    let username = '';
    let userCoins = 1000;
    let currentLevel = null;
    let savedLevels = [];
    let communityLevels = [];
    let officialLevels = [];
    let selectedTowerObj = null;
    let adminMode = false;
    let ownedSkins = {gunner: ['default'], sniper: ['default'], wizard: ['default'], rifle: ['default']};
    let activeSkins = {gunner: 'default', sniper: 'default', wizard: 'default', rifle: 'default'};
    let powerups = {damageBoost: false, freeze: false, priceReduction: false};
    
    // Cheat code listener
    let keyBuffer = '';
    document.addEventListener('keypress', (e) => {
      keyBuffer += e.key.toUpperCase();
      if (keyBuffer.length > 10) keyBuffer = keyBuffer.slice(-10);
      if (keyBuffer.includes('CUBERDEVV')) {
        adminMode = true;
        document.getElementById('adminPanel').style.display = 'block';
        keyBuffer = '';
      }
    });

    function setUsername() {
      const input = document.getElementById('usernameInput').value.trim();
      const message = document.getElementById('usernameMessage');
      
      if (input.length < 3) {
        message.textContent = 'Username must be at least 3 characters';
        message.style.color = '#F04747';
        return;
      }
      
      // Check if username exists (simulated)
      const existingUsers = ['admin', 'test', 'player1'];
      if (existingUsers.includes(input.toLowerCase())) {
        message.textContent = 'Error: Username taken';
        message.style.color = '#F04747';
        return;
      }
      
      username = input;
      message.textContent = 'Success!';
      message.style.color = '#43B581';
      
      let countdown = 5;
      const timer = setInterval(() => {
        countdown--;
        message.textContent = `Success! Closing in ${countdown}...`;
        if (countdown <= 0) {
          clearInterval(timer);
          document.getElementById('usernameModal').style.display = 'none';
          showScreen('mainMenu');
        }
      }, 1000);
    }

    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      currentScreen = screenId;
      
      if (screenId === 'shopMenu') {
        updateShop();
      } else if (screenId === 'officialLevels') {
        loadOfficialLevels();
      } else if (screenId === 'browseLevels') {
        loadCommunityLevels();
      }
    }

    function setTheme(theme) {
      if (theme === 'light') {
        document.body.classList.add('light-mode');
      } else {
        document.body.classList.remove('light-mode');
      }
    }

    // Shop System
    function switchShopTab(tab) {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      updateShop(tab);
    }

    function updateShop(tab = 'gunner') {
      document.getElementById('shopCoins').textContent = userCoins;
      const content = document.getElementById('shopContent');
      
      if (tab === 'powerups') {
        content.innerHTML = `
          <div class="shop-item">
            <span>Damage Boost (x2 damage)</span>
            <button class="menu-btn" style="width: auto; margin: 0;" onclick="buyPowerup('damageBoost', 500)">${powerups.damageBoost ? 'Owned' : '500 coins'}</button>
          </div>
          <div class="shop-item">
            <span>Freeze (Slow enemies 50%)</span>
            <button class="menu-btn" style="width: auto; margin: 0;" onclick="buyPowerup('freeze', 750)">${powerups.freeze ? 'Owned' : '750 coins'}</button>
          </div>
          <div class="shop-item">
            <span>Price Reduction (50% off towers)</span>
            <button class="menu-btn" style="width: auto; margin: 0;" onclick="buyPowerup('priceReduction', 1000)">${powerups.priceReduction ? 'Owned' : '1000 coins'}</button>
          </div>
        `;
      } else {
        const skins = ['default', 'gold', 'diamond', 'rainbow'];
        content.innerHTML = skins.map(skin => {
          const cost = skin === 'default' ? 0 : skin === 'gold' ? 200 : skin === 'diamond' ? 500 : 1000;
          const owned = ownedSkins[tab].includes(skin);
          const active = activeSkins[tab] === skin;
          return `
            <div class="shop-item">
              <span>${skin.charAt(0).toUpperCase() + skin.slice(1)} Skin</span>
              <button class="menu-btn" style="width: auto; margin: 0;" onclick="buySkin('${tab}', '${skin}', ${cost})">${active ? 'Active' : owned ? 'Equip' : cost + ' coins'}</button>
            </div>
          `;
        }).join('');
      }
    }

    function buySkin(tower, skin, cost) {
      if (ownedSkins[tower].includes(skin)) {
        activeSkins[tower] = skin;
        updateShop(tower);
      } else if (userCoins >= cost) {
        userCoins -= cost;
        ownedSkins[tower].push(skin);
        activeSkins[tower] = skin;
        updateShop(tower);
      } else {
        alert('Not enough coins!');
      }
    }

    function buyPowerup(type, cost) {
      if (powerups[type]) {
        alert('Already owned!');
      } else if (userCoins >= cost) {
        userCoins -= cost;
        powerups[type] = true;
        updateShop('powerups');
      } else {
        alert('Not enough coins!');
      }
    }

    // Admin Functions
    function closeAdmin() {
      document.getElementById('adminPanel').style.display = 'none';
    }

    function showAdminSection(section) {
      if (section === 'publishLevel') {
        const levelName = prompt('Enter saved level name to publish as official:');
        if (levelName) {
          const level = savedLevels.find(l => l.name === levelName);
          if (level) {
            officialLevels.push({...level, official: true});
            alert('Level published to official levels!');
          } else {
            alert('Level not found!');
          }
        }
      } else if (section === 'unpublishLevel') {
        const levelName = prompt('Enter official level name to unpublish:');
        if (levelName) {
          officialLevels = officialLevels.filter(l => l.name !== levelName);
          alert('Level unpublished!');
        }
      }
    }

    function giveCoins(amount) {
      userCoins += amount;
      if (userCoins < 0) userCoins = 0;
      alert(`Coins adjusted! New balance: ${userCoins}`);
    }

    // Level Editor
    const editorCanvas = document.getElementById('editorCanvas');
    const editorCtx = editorCanvas.getContext('2d');
    let editorGrid = [];
    let editorTool = 'road';
    let editorGridSize = 40;

    function createNewLevel() {
      resizeCanvas(editorCanvas);
      editorGrid = Array(Math.ceil(editorCanvas.height / editorGridSize)).fill(null).map(() => 
        Array(Math.ceil(editorCanvas.width / editorGridSize)).fill('empty')
      );
      showScreen('levelEditorScreen');
      drawEditorGrid();
      setupEditorListeners();
    }

    function setupEditorListeners() {
      document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          editorTool = this.dataset.tool;
        });
      });
      
      editorCanvas.addEventListener('click', (e) => {
        const rect = editorCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / editorGridSize);
        const y = Math.floor((e.clientY - rect.top) / editorGridSize);
        
        if (y < editorGrid.length && x < editorGrid[0].length) {
          if (editorTool === 'erase') {
            editorGrid[y][x] = 'empty';
          } else {
            editorGrid[y][x] = editorTool;
          }
          drawEditorGrid();
        }
      });
    }

    function drawEditorGrid() {
      editorCtx.fillStyle = '#36393F';
      editorCtx.fillRect(0, 0, editorCanvas.width, editorCanvas.height);
      
      for (let y = 0; y < editorGrid.length; y++) {
        for (let x = 0; x < editorGrid[0].length; x++) {
          const cell = editorGrid[y][x];
          const px = x * editorGridSize;
          const py = y * editorGridSize;
          
          if (cell === 'road') {
            editorCtx.fillStyle = '#4a5568';
          } else if (cell === 'rock') {
            editorCtx.fillStyle = '#718096';
          } else {
            editorCtx.fillStyle = '#2d3748';
          }
          
          editorCtx.fillRect(px, py, editorGridSize - 2, editorGridSize - 2);
        }
      }
      
      // Draw grid lines
      editorCtx.strokeStyle = '#1a202c';
      editorCtx.lineWidth = 1;
      for (let x = 0; x <= editorCanvas.width; x += editorGridSize) {
        editorCtx.beginPath();
        editorCtx.moveTo(x, 0);
        editorCtx.lineTo(x, editorCanvas.height);
        editorCtx.stroke();
      }
      for (let y = 0; y <= editorCanvas.height; y += editorGridSize) {
        editorCtx.beginPath();
        editorCtx.moveTo(0, y);
        editorCtx.lineTo(editorCanvas.width, y);
        editorCtx.stroke();
      }
    }

    function testLevel() {
      currentLevel = {grid: JSON.parse(JSON.stringify(editorGrid)), custom: true};
      startGame('normal', true);
    }

    function saveLevel() {
      const name = prompt('Enter level name:');
      if (name) {
        savedLevels.push({
          name: name,
          grid: JSON.parse(JSON.stringify(editorGrid)),
          author: username,
          date: new Date().toLocaleDateString()
        });
        alert('Level saved!');
      }
    }

    function publishLevel() {
      const name = prompt('Enter level name to publish:');
      if (name) {
        communityLevels.push({
          name: name,
          grid: JSON.parse(JSON.stringify(editorGrid)),
          author: username,
          date: new Date().toLocaleDateString()
        });
        alert('Level published to community!');
      }
    }

    function exitEditor() {
      showScreen('levelEditor');
    }

    function loadSavedLevels() {
      if (savedLevels.length === 0) {
        alert('No saved levels!');
        return;
      }
      const choice = prompt('Saved levels:\n' + savedLevels.map((l, i) => `${i + 1}. ${l.name}`).join('\n') + '\n\nEnter number:');
      const idx = parseInt(choice) - 1;
      if (idx >= 0 && idx < savedLevels.length) {
        editorGrid = JSON.parse(JSON.stringify(savedLevels[idx].grid));
        showScreen('levelEditorScreen');
        resizeCanvas(editorCanvas);
        drawEditorGrid();
        setupEditorListeners();
      }
    }

    function loadOfficialLevels() {
      const list = document.getElementById('officialLevelList');
      if (officialLevels.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #B9BBBE; padding: 20px;">No official levels yet</p>';
      } else {
        list.innerHTML = officialLevels.map((level, i) => `
          <div class="level-item" onclick="playCustomLevel(${i}, true)">
            <h3>${level.name}</h3>
            <p>By: ${level.author || 'Official'}</p>
            <p>Date: ${level.date}</p>
          </div>
        `).join('');
      }
    }

    function loadCommunityLevels() {
      const list = document.getElementById('communityLevelList');
      if (communityLevels.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #B9BBBE; padding: 20px;">No community levels yet</p>';
      } else {
        list.innerHTML = communityLevels.map((level, i) => `
          <div class="level-item" onclick="playCustomLevel(${i}, false)">
            <h3>${level.name}</h3>
            <p>By: ${level.author}</p>
            <p>Date: ${level.date}</p>
          </div>
        `).join('');
      }
    }

    function playCustomLevel(idx, isOfficial) {
      const level = isOfficial ? officialLevels[idx] : communityLevels[idx];
      currentLevel = {grid: JSON.parse(JSON.stringify(level.grid)), custom: true, name: level.name};
      startGame('normal', true);
    }

    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let game = null;
    let animationId = null;
    let gridSize = 50;
    let showGrid = false;
    let ghostTower = null;

    function resizeCanvas(cnv = canvas) {
      cnv.width = window.innerWidth;
      cnv.height = window.innerHeight;
    }

    const towerTypes = {
      gunner: {cost: 50, range: 120, damage: 10, fireRate: 2000, color: '#43B581', projectileSpeed: 6},
      sniper: {cost: 100, range: 300, damage: 20, fireRate: 3000, color: '#F04747', projectileSpeed: 10},
      wizard: {cost: 120, range: 100, damage: 2, fireRate: 2000, color: '#7289DA', poison: true, projectileSpeed: 4},
      rifle: {cost: 1000, range: 140, damage: 10, fireRate: 500, bullets: 2, color: '#FAA61A', projectileSpeed: 7}
    };

    const difficultySettings = {
      easy: {startGold: 300, startLives: 30, enemyHpMult: 0.7, enemySpeedMult: 0.8, maxWaves: 20},
      normal: {startGold: 200, startLives: 20, enemyHpMult: 1, enemySpeedMult: 1, maxWaves: 40},
      hard: {startGold: 150, startLives: 15, enemyHpMult: 1.3, enemySpeedMult: 1.2, maxWaves: 60},
      expert: {startGold: 100, startLives: 10, enemyHpMult: 1.6, enemySpeedMult: 1.4, maxWaves: 100}
    };

    function startGame(difficulty, isCustom = false) {
      resizeCanvas();
      window.addEventListener('resize', () => resizeCanvas());
      
      const settings = difficultySettings[difficulty];
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      game = {
        difficulty: difficulty,
        gold: settings.startGold,
        lives: settings.startLives,
        wave: 1,
        towers: [],
        enemies: [],
        projectiles: [],
        selectedTower: null,
        waveActive: false,
        enemiesSpawned: 0,
        enemiesInWave: 10,
        path: isCustom ? generatePathFromGrid() : generatePath(),
        settings: settings,
        bossSpawned: false,
        isCustom: isCustom,
        grid: isCustom ? currentLevel.grid : null
      };
      
      if (powerups.priceReduction) {
        Object.keys(towerTypes).forEach(key => {
          towerTypes[key].cost = Math.floor(towerTypes[key].cost * 0.5);
        });
      }
      
      showScreen('gameScreen');
      updateHUD();
      setupGameListeners();
      gameLoop();
    }

    function generatePathFromGrid() {
      const path = [];
      const grid = currentLevel.grid;
      
      // Find road tiles and create path
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
          if (grid[y][x] === 'road') {
            path.push({x: x * editorGridSize + editorGridSize / 2, y: y * editorGridSize + editorGridSize / 2});
          }
        }
      }
      
      return path.length > 0 ? path : generatePath();
    }

    function generatePath() {
      const w = canvas.width;
      const h = canvas.height;
      return [
        {x: -50, y: h * 0.2},
        {x: w * 0.25, y: h * 0.2},
        {x: w * 0.25, y: h * 0.6},
        {x: w * 0.5, y: h * 0.6},
        {x: w * 0.5, y: h * 0.3},
        {x: w * 0.75, y: h * 0.3},
        {x: w * 0.75, y: h * 0.7},
        {x: w + 50, y: h * 0.7}
      ];
    }

    function setupGameListeners() {
      canvas.onclick = null;
      canvas.onmousemove = null;
      
      canvas.addEventListener('mousemove', (e) => {
        if (game.selectedTower) {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          ghostTower = {
            x: Math.floor(x / gridSize) * gridSize + gridSize / 2,
            y: Math.floor(y / gridSize) * gridSize + gridSize / 2,
            type: game.selectedTower
          };
        } else {
          ghostTower = null;
        }
      });
      
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if clicking on existing tower
        const clickedTower = game.towers.find(t => 
          Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < 25
        );
        
        if (clickedTower) {
          showTowerUI(clickedTower, e.clientX, e.clientY);
          return;
        }
        
        if (!game.selectedTower) return;
        
        const snapX = Math.floor(x / gridSize) * gridSize + gridSize / 2;
        const snapY = Math.floor(y / gridSize) * gridSize + gridSize / 2;
        
        // Check for rocks in custom levels
        if (game.isCustom && game.grid) {
          const gridX = Math.floor(snapX / editorGridSize);
          const gridY = Math.floor(snapY / editorGridSize);
          if (gridY < game.grid.length && gridX < game.grid[0].length) {
            if (game.grid[gridY][gridX] === 'rock' && game.selectedTower !== 'sniper') {
              alert('Cannot place tower on rock! (Only snipers can)');
              return;
            }
          }
        }
        
        // Check if on path
        const onPath = game.path.some((p, i) => {
          if (i === 0) return false;
          const prev = game.path[i - 1];
          const d = distanceToSegment(snapX, snapY, prev.x, prev.y, p.x, p.y);
          return d < 50;
        });
        
        // Check if too close to other towers
        const tooClose = game.towers.some(t => 
          Math.sqrt((t.x - snapX) ** 2 + (t.y - snapY) ** 2) < gridSize
        );
        
        if (!onPath && !tooClose) {
          const cost = towerTypes[game.selectedTower].cost;
          if (game.gold >= cost) {
            placeTower(snapX, snapY, game.selectedTower);
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            game.selectedTower = null;
            showGrid = false;
            ghostTower = null;
          }
        } else if (tooClose) {
          alert('Too close to another tower!');
        }
      });
    }

    function showTowerUI(tower, x, y) {
      selectedTowerObj = tower;
      const ui = document.getElementById('towerUI');
      ui.style.display = 'block';
      ui.style.left = x + 'px';
      ui.style.top = y + 'px';
      
      document.getElementById('towerUITitle').textContent = tower.type.toUpperCase();
      document.getElementById('upgradeCost').textContent = tower.upgrades ? tower.upgrades * 100 : 100;
      document.getElementById('towerTarget').value = tower.targetType || 'first';
    }

    function closeTowerUI() {
      document.getElementById('towerUI').style.display = 'none';
      selectedTowerObj = null;
    }

    function upgradeTower() {
      if (!selectedTowerObj) return;
      const cost = (selectedTowerObj.upgrades || 0) * 100 + 100;
      
      if (game.gold >= cost) {
        game.gold -= cost;
        selectedTowerObj.upgrades = (selectedTowerObj.upgrades || 0) + 1;
        selectedTowerObj.damage = Math.floor(selectedTowerObj.damage * 1.5);
        selectedTowerObj.range = Math.floor(selectedTowerObj.range * 1.1);
        updateHUD();
        closeTowerUI();
        alert('Tower upgraded!');
      } else {
        alert('Not enough gold!');
      }
    }

    function changeTowerTarget() {
      if (!selectedTowerObj) return;
      selectedTowerObj.targetType = document.getElementById('towerTarget').value;
    }

    function startWave() {
      game.waveActive = true;
      game.enemiesSpawned = 0;
      game.bossSpawned = false;
      document.getElementById('startWaveBtn').disabled = true;
      
      const spawnInterval = setInterval(() => {
        if (game.enemiesSpawned < game.enemiesInWave) {
          spawnEnemy();
        } else {
          clearInterval(spawnInterval);
        }
      }, 800);
    }

    function spawnEnemy() {
      const types = ['zombie', 'speed', 'tank'];
      let type = types[Math.floor(Math.random() * types.length)];
      
      if (game.wave % 10 === 0 && !game.bossSpawned) {
        type = 'boss';
        game.bossSpawned = true;
      }
      
      if (game.wave >= 15 && Math.random() < 0.05) {
        type = 'king';
      }
      
      const enemyStats = {
        zombie: {hp: 50, speed: 1.5, reward: 10, size: 12, color: '#95a5a6'},
        speed: {hp: 30, speed: 3, reward: 15, size: 10, color: '#3498db'},
        tank: {hp: 150, speed: 0.8, reward: 30, size: 18, color: '#e74c3c'},
        boss: {hp: 500 + (Math.floor(game.wave / 10) - 1) * 300, speed: 0.6, reward: 100, size: 25, color: '#8e44ad'},
        king: {hp: 300, speed: 1, reward: 80, size: 22, color: '#f39c12', isKing: true}
      };
      
      const stats = enemyStats[type];
      const mult = game.settings.enemyHpMult;
      const speedMult = powerups.freeze ? game.settings.enemySpeedMult * 0.5 : game.settings.enemySpeedMult;
      
      game.enemies.push({
        type: type,
        x: game.path[0].x,
        y: game.path[0].y,
        pathIndex: 0,
        hp: stats.hp * mult * (1 + game.wave * 0.1),
        maxHp: stats.hp * mult * (1 + game.wave * 0.1),
        speed: stats.speed * speedMult,
        reward: stats.reward,
        size: stats.size,
        color: stats.color,
        isKing: stats.isKing || false,
        lastSpawn: Date.now(),
        poisoned: false,
        poisonTicks: 0
      });
      
      game.enemiesSpawned++;
    }

    function updateEnemies() {
      for (let i = game.enemies.length - 1; i >= 0; i--) {
        const e = game.enemies[i];
        
        if (e.isKing && Date.now() - e.lastSpawn > 5000) {
          e.lastSpawn = Date.now();
          const spawnType = Math.random() < 0.3 ? 'tank' : 'zombie';
          const stats = spawnType === 'tank' ? 
            {hp: 150, speed: 0.8, reward: 30, size: 18, color: '#e74c3c'} :
            {hp: 50, speed: 1.5, reward: 10, size: 12, color: '#95a5a6'};
          
          game.enemies.push({
            type: spawnType,
            x: e.x,
            y: e.y,
            pathIndex: e.pathIndex,
            hp: stats.hp,
            maxHp: stats.hp,
            speed: stats.speed,
            reward: stats.reward,
            size: stats.size,
            color: stats.color,
            poisoned: false,
            poisonTicks: 0
          });
        }
        
        if (e.poisoned && e.poisonTicks > 0) {
          if (Date.now() % 500 < 16) {
            e.hp -= 2;
            e.poisonTicks--;
          }
        }
        
        if (e.pathIndex < game.path.length - 1) {
          const target = game.path[e.pathIndex + 1];
          const dx = target.x - e.x;
          const dy = target.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < e.speed) {
            e.pathIndex++;
          } else {
            e.x += (dx / dist) * e.speed;
            e.y += (dy / dist) * e.speed;
          }
        } else {
          game.lives--;
          game.enemies.splice(i, 1);
          updateHUD();
          if (game.lives <= 0) {
            endGame();
          }
        }
        
        if (e.hp <= 0) {
          game.gold += e.reward;
          userCoins += Math.floor(e.reward / 2);
          game.enemies.splice(i, 1);
          updateHUD();
        }
      }
    }

    function updateTowers() {
      const now = Date.now();
      game.towers.forEach(t => {
        if (now - t.lastFire >= t.fireRate) {
          let target = null;
          let maxProgress = -1;
          
          game.enemies.forEach(e => {
            const dist = Math.sqrt((e.x - t.x) ** 2 + (e.y - t.y) ** 2);
            const matchesTarget = !t.targetType || t.targetType === 'first' || e.type === t.targetType;
            
            if (dist <= t.range && matchesTarget && e.pathIndex > maxProgress) {
              maxProgress = e.pathIndex;
              target = e;
            }
          });
          
          if (target) {
            const bullets = t.bullets || 1;
            for (let i = 0; i < bullets; i++) {
              setTimeout(() => {
                if (game && game.projectiles) {
                  game.projectiles.push({
                    x: t.x,
                    y: t.y,
                    targetX: target.x,
                    targetY: target.y,
                    target: target,
                    damage: powerups.damageBoost ? t.damage * 2 : t.damage,
                    speed: t.projectileSpeed,
                    color: t.color,
                    poison: t.poison
                  });
                }
              }, i * 100);
            }
            t.lastFire = now;
          }
        }
      });
    }

    function updateProjectiles() {
      for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const p = game.projectiles[i];
        const dx = p.targetX - p.x;
        const dy = p.targetY - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < p.speed) {
          if (p.target && game.enemies.includes(p.target)) {
            p.target.hp -= p.damage;
            if (p.poison) {
              p.target.poisoned = true;
              p.target.poisonTicks = 5;
            }
          }
          game.projectiles.splice(i, 1);
        } else {
          p.x += (dx / dist) * p.speed;
          p.y += (dy / dist) * p.speed;
        }
      }
    }

    function drawPath() {
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 80;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(game.path[0].x, game.path[0].y);
      for (let i = 1; i < game.path.length; i++) {
        ctx.lineTo(game.path[i].x, game.path[i].y);
      }
      ctx.stroke();
    }

    function drawGrid() {
      if (!showGrid && !game.selectedTower) return;
      
      ctx.strokeStyle = 'rgba(114, 137, 218, 0.2)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawGhostTower() {
      if (!ghostTower) return;
      
      const specs = towerTypes[ghostTower.type];
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = specs.color;
      ctx.fillRect(ghostTower.x - 20, ghostTower.y - 20, 40, 40);
      
      ctx.strokeStyle = specs.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(ghostTower.x, ghostTower.y, specs.range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawEnemies() {
      game.enemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
        ctx.fill();
        
        if (e.isKing) {
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('üëë', e.x, e.y - e.size - 5);
        }
        
        if (e.poisoned) {
          ctx.fillStyle = '#7289DA';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('‚ò†', e.x, e.y + e.size + 12);
        }
        
        const barWidth = e.size * 2;
        const barHeight = 5;
        ctx.fillStyle = '#2F3136';
        ctx.fillRect(e.x - barWidth/2, e.y - e.size - 10, barWidth, barHeight);
        ctx.fillStyle = '#43B581';
        ctx.fillRect(e.x - barWidth/2, e.y - e.size - 10, barWidth * (e.hp / e.maxHp), barHeight);
      });
    }

    function drawTowers() {
      game.towers.forEach(t => {
        const skin = activeSkins[t.type];
        let color = t.color;
        
        if (skin === 'gold') color = '#FFD700';
        else if (skin === 'diamond') color = '#B9F2FF';
        else if (skin === 'rainbow') {
          const hue = (Date.now() / 10) % 360;
          color = `hsl(${hue}, 70%, 60%)`;
        }
        
        ctx.fillStyle = color;
        ctx.fillRect(t.x - 20, t.y - 20, 40, 40);
        ctx.strokeStyle = '#2F3136';
        ctx.lineWidth = 3;
        ctx.strokeRect(t.x - 20, t.y - 20, 40, 40);
        
        if (t.upgrades) {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`+${t.upgrades}`, t.x, t.y + 35);
        }
      });
    }

    function drawProjectiles() {
      game.projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawRocks() {
      if (!game.isCustom || !game.grid) return;
      
      for (let y = 0; y < game.grid.length; y++) {
        for (let x = 0; x < game.grid[0].length; x++) {
          if (game.grid[y][x] === 'rock') {
            ctx.fillStyle = '#718096';
            ctx.fillRect(x * editorGridSize, y * editorGridSize, editorGridSize, editorGridSize);
          }
        }
      }
    }

    function gameLoop() {
      if (!game) return;
      
      ctx.fillStyle = document.body.classList.contains('light-mode') ? '#f0f4f8' : '#36393F';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      drawRocks();
      drawPath();
      drawGrid();
      drawGhostTower();
      updateEnemies();
      updateTowers();
      updateProjectiles();
      drawEnemies();
      drawTowers();
      drawProjectiles();
      
      if (game.waveActive && game.enemies.length === 0 && game.enemiesSpawned >= game.enemiesInWave) {
        game.waveActive = false;
        
        if (game.wave >= game.settings.maxWaves) {
          showCompletionScreen();
          return;
        }
        
        game.wave++;
        game.enemiesInWave += 5;
        game.enemiesSpawned = 0;
        game.gold += 50;
        userCoins += 20;
        updateHUD();
        document.getElementById('startWaveBtn').disabled = false;
      }
      
      animationId = requestAnimationFrame(gameLoop);
    }

    function showCompletionScreen() {
      cancelAnimationFrame(animationId);
      document.getElementById('completionMessage').textContent = `You completed all ${game.settings.maxWaves} waves!`;
      document.getElementById('completionScreen').style.display = 'block';
    }

    function nextLevel() {
      document.getElementById('completionScreen').style.display = 'none';
      alert('Error: No more levels');
    }

    function restartLevel() {
      document.getElementById('completionScreen').style.display = 'none';
      const diff = game.difficulty;
      const custom = game.isCustom;
      startGame(diff, custom);
    }

    function placeTower(x, y, type) {
      const specs = towerTypes[type];
      game.towers.push({
        x: x,
        y: y,
        type: type,
        range: specs.range,
        damage: specs.damage,
        fireRate: specs.fireRate,
        lastFire: 0,
        color: specs.color,
        poison: specs.poison || false,
        bullets: specs.bullets || 1,
        projectileSpeed: specs.projectileSpeed,
        upgrades: 0,
        targetType: 'first'
      });
      game.gold -= specs.cost;
      updateHUD();
    }

    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const len = dx * dx + dy * dy;
      let t = ((px - x1) * dx + (py - y1) * dy) / len;
      t = Math.max(0, Math.min(1, t));
      const nearX = x1 + t * dx;
      const nearY = y1 + t * dy;
      return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);
    }

    document.querySelectorAll('.tower-btn[data-tower]').forEach(btn => {
      btn.addEventListener('click', function() {
        const tower = this.dataset.tower;
        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
        this.classList.add('selected');
        game.selectedTower = tower;
        showGrid = true;
      });
    });

    function updateHUD() {
      if (!game) return;
      document.getElementById('gold').textContent = game.gold;
      document.getElementById('lives').textContent = game.lives;
      document.getElementById('wave').textContent = game.wave;
      
      document.querySelectorAll('.tower-btn').forEach(btn => {
        const type = btn.dataset.tower;
        if (type && towerTypes[type]) {
          btn.disabled = game.gold < towerTypes[type].cost;
        }
      });
    }

    function endGame() {
      cancelAnimationFrame(animationId);
      alert(`Game Over! You survived ${game.wave} waves!`);
      leaveGame();
    }

    function leaveGame() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      game = null;
      ghostTower = null;
      showGrid = false;
      document.getElementById('completionScreen').style.display = 'none';
      showScreen('mainMenu');
    }
  </script>
</body>
</html>
